package com.singularityuniverse.prometheus.ui.component

import androidx.compose.foundation.layout.*
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.singularityuniverse.prometheus.entity.Project
import com.singularityuniverse.prometheus.utils.GnuplotGenerator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.nio.ByteBuffer
import kotlin.math.min
import kotlin.math.sqrt

@Composable
fun Landscape(project: Project) {
    val scope = rememberCoroutineScope()
    val metadata = project.metadata
    val neuronsPerLayer = metadata["neuronsPerLayer"]?.toInt() ?: 0
    val layerCount = metadata["layerCount"]?.toInt() ?: 0
    
    var biasData by remember { mutableStateOf<List<Float>?>(null) }
    var weightData by remember { mutableStateOf<List<Float>?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    var error by remember { mutableStateOf<String?>(null) }
    var scriptGenerated by remember { mutableStateOf(false) }
    var isGeneratingScript by remember { mutableStateOf(false) }

    LaunchedEffect(project) {
        withContext(Dispatchers.IO) {
            try {
                // Load bias data
                val biasArray = mutableListOf<Float>()
                project.biasFile.inputStream().buffered().use { inputStream ->
                    val buffer = ByteArray(neuronsPerLayer * layerCount * 4)
                    val bytesRead = inputStream.read(buffer)
                    if (bytesRead > 0) {
                        val byteBuffer = ByteBuffer.wrap(buffer, 0, bytesRead)
                        repeat(bytesRead / 4) {
                            biasArray.add(byteBuffer.getFloat())
                        }
                    }
                }
                
                // Load weight data (sample for visualization)
                val weightArray = mutableListOf<Float>()
                if (project.weightFile.exists()) {
                    project.weightFile.inputStream().buffered().use { inputStream ->
                        val buffer = ByteArray(min(1024 * 1024, inputStream.available())) // Limit to 1MB for performance
                        val bytesRead = inputStream.read(buffer)
                        if (bytesRead > 0) {
                            val byteBuffer = ByteBuffer.wrap(buffer, 0, bytesRead)
                            repeat(bytesRead / 4) {
                                weightArray.add(byteBuffer.getFloat())
                            }
                        }
                    }
                }
                
                biasData = biasArray
                weightData = weightArray
                isLoading = false
            } catch (e: Exception) {
                error = "Failed to load model data: ${e.message}"
                isLoading = false
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Header
        Card(
            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Neural Network Landscape",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text("Model: ${metadata["modelName"] ?: "Unknown"}")
                Text("Layers: $layerCount")
                Text("Neurons per Layer: $neuronsPerLayer")
                Text("Total Parameters: ${metadata["totalParameters"] ?: "Unknown"}")
                Text("Bias Mode: ${metadata["biasMode"] ?: "Unknown"}")
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Generate Gnuplot Script Button
                Button(
                    onClick = {
                        isGeneratingScript = true
                        scope.launch {
                            try {
                                val success = GnuplotGenerator.generateGnuplotScript(
                                    project = project,
                                    biasData = biasData ?: emptyList(),
                                    weightData = weightData
                                )
                                scriptGenerated = success
                                if (!success) {
                                    error = "Failed to generate gnuplot script"
                                }
                            } catch (e: Exception) {
                                error = "Error generating script: ${e.message}"
                            } finally {
                                isGeneratingScript = false
                            }
                        }
                    },
                    enabled = !isLoading && biasData != null && !isGeneratingScript
                ) {
                    Text(
                        when {
                            isGeneratingScript -> "Generating..."
                            scriptGenerated -> "Gnuplot Script Generated!"
                            else -> "Generate Gnuplot Script"
                        }
                    )
                }
                
                if (scriptGenerated) {
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        "Gnuplot script generated at: ${project.path}/gnuplot-script",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                    Text(
                        "Run: cd \"${project.path}\" && ./gnuplot-script",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.secondary
                    )
                }
            }
        }

        when {
            isLoading -> {
                Box(
                    modifier = Modifier.fillMaxWidth().height(200.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text("Loading model data...")
                }
            }
            
            error != null -> {
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        text = error!!,
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }
            
            biasData != null -> {
                // Show basic statistics while the original visualizations are commented out
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Data Loaded - Ready for Gnuplot Generation",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            modifier = Modifier.padding(bottom = 8.dp)
                        )
                        
                        ModelStatistics(
                            biasData = biasData!!,
                            weightData = weightData
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ModelStatistics(
    biasData: List<Float>,
    weightData: List<Float>?
) {
    Column {
        Text("Bias Statistics:")
        if (biasData.isNotEmpty()) {
            val mean = biasData.average()
            val variance = biasData.map { (it - mean) * (it - mean) }.average()
            val stdDev = sqrt(variance)
            
            Text("  Mean: ${"%.6f".format(mean)}")
            Text("  Std Dev: ${"%.6f".format(stdDev)}")
            Text("  Min: ${"%.6f".format(biasData.minOrNull() ?: 0f)}")
            Text("  Max: ${"%.6f".format(biasData.maxOrNull() ?: 0f)}")
            Text("  Count: ${biasData.size}")
        }
        
        Spacer(modifier = Modifier.height(8.dp))
        
        Text("Weight Statistics:")
        if (weightData != null && weightData.isNotEmpty()) {
            val mean = weightData.average()
            val variance = weightData.map { (it - mean) * (it - mean) }.average()
            val stdDev = sqrt(variance)
            
            Text("  Mean: ${"%.6f".format(mean)}")
            Text("  Std Dev: ${"%.6f".format(stdDev)}")
            Text("  Min: ${"%.6f".format(weightData.minOrNull() ?: 0f)}")
            Text("  Max: ${"%.6f".format(weightData.maxOrNull() ?: 0f)}")
            Text("  Sample Size: ${weightData.size} (limited for performance)")
        } else {
            Text("  No weight data available")
        }
    }
}
