package com.singularityuniverse.prometheus.ui.component

import androidx.compose.foundation.layout.*
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.singularityuniverse.prometheus.entity.Project
import com.singularityuniverse.prometheus.utils.GnuplotGenerator
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.nio.ByteBuffer
import java.util.concurrent.TimeUnit
import kotlin.math.min
import kotlin.math.sqrt

// Data class to hold basic model statistics without storing the full data
data class ModelStats(
    val biasCount: Int,
    val biasMean: Double,
    val biasStdDev: Double,
    val biasMin: Float,
    val biasMax: Float,
    val weightCount: Int?,
    val weightMean: Double?,
    val weightStdDev: Double?,
    val weightMin: Float?,
    val weightMax: Float?
)

class LandscapeState(val project: Project) {
    private val scope = CoroutineScope(Dispatchers.IO)

    val metadata = project.metadata
    val neuronsPerLayer = metadata["neuronsPerLayer"]?.toInt() ?: 0
    val layerCount = metadata["layerCount"]?.toInt() ?: 0

    var dataValidated by mutableStateOf(false)
    var isLoading by mutableStateOf(true)
    var error by mutableStateOf<String?>(null)
    var scriptGenerated by mutableStateOf(false)
    var isGeneratingScript by mutableStateOf(false)
    var modelStats by mutableStateOf<ModelStats?>(null)

    init {
        scope.launch {
            runCatching {
                // Validate that required files exist
                if (!project.biasFile.exists()) {
                    error = "Bias file not found: ${project.biasFile.absolutePath}"
                    isLoading = false
                }
            }.onSuccess {
                // Calculate statistics without loading full data
                modelStats = calculateModelStats()
                dataValidated = true
                isLoading = false
            }.onFailure { e ->
                error = "Failed to validate model data: ${e.message}"
                isLoading = false
            }
        }
    }

    // Function to calculate statistics from file without loading all data into memory
    suspend fun calculateModelStats(): ModelStats = withContext(Dispatchers.IO) {
        // Calculate bias statistics
        var biasSum = 0.0
        var biasCount = 0
        var biasMin = Float.MAX_VALUE
        var biasMax = Float.MIN_VALUE
        val biasValues = mutableListOf<Float>() // Only for std dev calculation

        project.biasFile.inputStream().buffered().use { inputStream ->
            val buffer = ByteArray(8192) // 8KB buffer for reading
            val byteBuffer = ByteBuffer.allocate(8192)

            var bytesRead: Int
            while (inputStream.read(buffer).also { bytesRead = it } > 0) {
                byteBuffer.clear()
                byteBuffer.put(buffer, 0, bytesRead)
                byteBuffer.flip()

                while (byteBuffer.remaining() >= 4) {
                    val value = byteBuffer.getFloat()
                    biasValues.add(value)
                    biasSum += value
                    biasCount++
                    if (value < biasMin) biasMin = value
                    if (value > biasMax) biasMax = value
                }
            }
        }

        val biasMean = if (biasCount > 0) biasSum / biasCount else 0.0
        val biasVariance = if (biasCount > 0) {
            biasValues.map { (it - biasMean) * (it - biasMean) }.average()
        } else 0.0
        val biasStdDev = sqrt(biasVariance)

        // Calculate weight statistics (sample-based for large files)
        var weightStats: Map<String, Any>? = null
        if (project.weightFile.exists()) {
            val maxSampleSize = 100000 // Sample up to 100k weights for statistics
            val weightSample = mutableListOf<Float>()

            project.weightFile.inputStream().buffered().use { inputStream ->
                val buffer = ByteArray(min(maxSampleSize * 4, inputStream.available()))
                val bytesRead = inputStream.read(buffer)
                if (bytesRead > 0) {
                    val byteBuffer = ByteBuffer.wrap(buffer, 0, bytesRead)
                    while (byteBuffer.remaining() >= 4) {
                        weightSample.add(byteBuffer.getFloat())
                    }
                }
            }

            if (weightSample.isNotEmpty()) {
                val weightMean = weightSample.average()
                val weightVariance = weightSample.map { (it - weightMean) * (it - weightMean) }.average()
                val weightStdDev = sqrt(weightVariance)

                weightStats = mapOf(
                    "count" to weightSample.size,
                    "mean" to weightMean,
                    "stdDev" to weightStdDev,
                    "min" to (weightSample.minOrNull() ?: 0f),
                    "max" to (weightSample.maxOrNull() ?: 0f)
                )
            }
        }

        ModelStats(
            biasCount = biasCount,
            biasMean = biasMean,
            biasStdDev = biasStdDev,
            biasMin = if (biasCount > 0) biasMin else 0f,
            biasMax = if (biasCount > 0) biasMax else 0f,
            weightCount = weightStats?.get("count") as? Int,
            weightMean = weightStats?.get("mean") as? Double,
            weightStdDev = weightStats?.get("stdDev") as? Double,
            weightMin = weightStats?.get("min") as? Float,
            weightMax = weightStats?.get("max") as? Float
        )
    }

    suspend fun generatePlotScript(): Unit = withContext(Dispatchers.IO) {
        isGeneratingScript = true
        runCatching {
            val success = GnuplotGenerator.generateGnuplotScript(project)
            scriptGenerated = success
            if (!success) {
                error = "Failed to generate gnuplot script"
            }
        }.onFailure { e ->
            error = "Error generating script: ${e.message}"
        }

        isGeneratingScript = false
    }

    suspend fun executePlotScript(): Unit = withContext(Dispatchers.IO) {
        runCatching {
            val gnuplotDir = File(File(project.uri), "gnuplot")
            val scriptFile = File(gnuplotDir, "gnuplot-script")
            if (!scriptFile.exists()) {
                error = "Gnuplot script not found at: ${scriptFile.absolutePath}"
                return@runCatching
            }

            // Make the script executable on Unix-like systems
            if (!System.getProperty("os.name").lowercase().contains("windows")) {
                ProcessBuilder("chmod", "+x", scriptFile.absolutePath)
                    .start()
                    .waitFor()
            }

            // Execute the gnuplot script
            val processBuilder = if (System.getProperty("os.name").lowercase().contains("windows")) {
                ProcessBuilder("cmd", "/c", scriptFile.absolutePath)
            } else {
                ProcessBuilder("bash", "-c", "cd \"${gnuplotDir.absolutePath}\" && ./gnuplot-script")
            }

            processBuilder.directory()
            val process = processBuilder.start()

            // Wait for completion with timeout
            val completed = process.waitFor(30, TimeUnit.SECONDS)

            if (!completed) {
                process.destroyForcibly()
                error = "Gnuplot execution timed out after 30 seconds"
            } else if (process.exitValue() != 0) {
                val errorOutput = process.errorStream.bufferedReader().readText()
                error = "Gnuplot execution failed with exit code ${process.exitValue()}: $errorOutput"
            } else {
                // Success - check if output files were generated in the gnuplot directory
                val outputFiles = gnuplotDir.listFiles { file ->
                    file.extension.lowercase() in listOf("png", "jpg", "jpeg", "svg", "pdf", "eps")
                }

                if (outputFiles?.isNotEmpty() == true) {
                    error = null // Clear any previous errors
                    println("Gnuplot execution completed successfully. Generated files: ${outputFiles.map { it.name }}")
                } else {
                    error = "Gnuplot completed but no output files were generated"
                }
            }
        }.onFailure { e ->
            error = "Failed to execute gnuplot script: ${e.message}"
        }
    }
}

@Composable
fun Landscape(state: LandscapeState) {
    val scope = rememberCoroutineScope()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Header
        Card(
            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Neural Network Landscape",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text("Model: ${state.metadata["modelName"] ?: "Unknown"}")
                Text("Layers: ${state.layerCount}layerCount")
                Text("Neurons per Layer: ${state.neuronsPerLayer}neuronsPerLayer")
                Text("Total Parameters: ${state.metadata["totalParameters"] ?: "Unknown"}")
                Text("Bias Mode: ${state.metadata["biasMode"] ?: "Unknown"}")

                Spacer(modifier = Modifier.height(16.dp))

                // Generate Gnuplot Script Button
                Button(
                    onClick = {
                        scope.launch {
                            state.generatePlotScript()
                            state.executePlotScript()
                        }
                    },
                    enabled = state.dataValidated && !state.isGeneratingScript
                ) {
                    Text(
                        when {
                            state.isGeneratingScript -> "Generating..."
                            state.scriptGenerated -> "Gnuplot Script Generated!"
                            else -> "Generate Gnuplot Script"
                        }
                    )
                }

                if (state.scriptGenerated) {
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        "Gnuplot script generated at: ${state.project.uri}gnuplot/gnuplot-script",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                    Text(
                        "Run: cd \"${state.project.uri}gnuplot\" && ./gnuplot-script",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.secondary
                    )
                }
            }
        }

        when {
            state.isLoading -> {
                Box(
                    modifier = Modifier.fillMaxWidth().height(200.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text("Loading model data...")
                }
            }

            state.error != null -> {
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        text = state.error!!,
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }

            state.dataValidated && state.modelStats != null -> {
                // Show basic statistics
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Data Validated - Ready for Gnuplot Generation",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            modifier = Modifier.padding(bottom = 8.dp)
                        )

                        ModelStatisticsDisplay(modelStats = state.modelStats!!)
                    }
                }
            }
        }
    }
}

@Composable
private fun ModelStatisticsDisplay(modelStats: ModelStats) {
    Column {
        Text("Bias Statistics:")
        Text("  Mean: ${"%.6f".format(modelStats.biasMean)}")
        Text("  Std Dev: ${"%.6f".format(modelStats.biasStdDev)}")
        Text("  Min: ${"%.6f".format(modelStats.biasMin)}")
        Text("  Max: ${"%.6f".format(modelStats.biasMax)}")
        Text("  Count: ${modelStats.biasCount}")

        Spacer(modifier = Modifier.height(8.dp))

        Text("Weight Statistics:")
        if (modelStats.weightCount != null && modelStats.weightMean != null) {
            Text("  Mean: ${"%.6f".format(modelStats.weightMean)}")
            Text("  Std Dev: ${"%.6f".format(modelStats.weightStdDev ?: 0.0)}")
            Text("  Min: ${"%.6f".format(modelStats.weightMin ?: 0f)}")
            Text("  Max: ${"%.6f".format(modelStats.weightMax ?: 0f)}")
            Text("  Sample Size: ${modelStats.weightCount} (sampled for performance)")
        } else {
            Text("  No weight data available")
        }
    }
}
