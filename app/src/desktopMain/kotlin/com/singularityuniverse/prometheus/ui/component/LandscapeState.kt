package com.singularityuniverse.prometheus.ui.component

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.toComposeImageBitmap
import com.singularityuniverse.prometheus.entity.Project
import com.singularityuniverse.prometheus.utils.GnuplotGenerator
import kotlinx.coroutines.*
import org.jetbrains.skia.Image
import java.io.File
import java.nio.ByteBuffer
import java.util.concurrent.TimeUnit
import kotlin.math.min
import kotlin.math.sqrt
import kotlin.time.Duration.Companion.minutes

class LandscapeState(val project: Project) {
    private val scope = CoroutineScope(Dispatchers.IO)

    private val surfaceImageFile = File(File(project.uri), "gnuplot/bias_surface.png")
    private val heatmapImageFile = File(File(project.uri), "gnuplot/bias_heatmap.png")

    val metadata = project.metadata
    val neuronsPerLayer = metadata["neuronsPerLayer"]?.toInt() ?: 0
    val layerCount = metadata["layerCount"]?.toInt() ?: 0

    var dataValidated by mutableStateOf(false)
    var isLoading by mutableStateOf(true)
    var error by mutableStateOf<String?>(null)
    var scriptGenerated by mutableStateOf(false)
    var isGeneratingScript by mutableStateOf(false)
    var modelStats by mutableStateOf<ModelStats?>(null)
    var heatmapImage by mutableStateOf<ImageBitmap?>(null)
    var surfaceImage by mutableStateOf<ImageBitmap?>(null)

    init {
        scope.launch {
            reload()
        }
    }

    // Function to calculate statistics from file without loading all data into memory
    suspend fun calculateModelStats(): ModelStats = withContext(Dispatchers.IO) {
        // Calculate bias statistics
        var biasSum = 0.0
        var biasCount = 0
        var biasMin = Float.MAX_VALUE
        var biasMax = Float.MIN_VALUE
        val biasValues = mutableListOf<Float>() // Only for std dev calculation

        project.biasFile.inputStream().buffered().use { inputStream ->
            val buffer = ByteArray(8192) // 8KB buffer for reading
            val byteBuffer = ByteBuffer.allocate(8192)

            var bytesRead: Int
            while (inputStream.read(buffer).also { bytesRead = it } > 0) {
                byteBuffer.clear()
                byteBuffer.put(buffer, 0, bytesRead)
                byteBuffer.flip()

                while (byteBuffer.remaining() >= 4) {
                    val value = byteBuffer.getFloat()
                    biasValues.add(value)
                    biasSum += value
                    biasCount++
                    if (value < biasMin) biasMin = value
                    if (value > biasMax) biasMax = value
                }
            }
        }

        val biasMean = if (biasCount > 0) biasSum / biasCount else 0.0
        val biasVariance = if (biasCount > 0) {
            biasValues.map { (it - biasMean) * (it - biasMean) }.average()
        } else 0.0
        val biasStdDev = sqrt(biasVariance)

        // Calculate weight statistics (sample-based for large files)
        var weightStats: Map<String, Any>? = null
        if (project.weightFile.exists()) {
            val maxSampleSize = 100000 // Sample up to 100k weights for statistics
            val weightSample = mutableListOf<Float>()

            project.weightFile.inputStream().buffered().use { inputStream ->
                val buffer = ByteArray(min(maxSampleSize * 4, inputStream.available()))
                val bytesRead = inputStream.read(buffer)
                if (bytesRead > 0) {
                    val byteBuffer = ByteBuffer.wrap(buffer, 0, bytesRead)
                    while (byteBuffer.remaining() >= 4) {
                        weightSample.add(byteBuffer.getFloat())
                    }
                }
            }

            if (weightSample.isNotEmpty()) {
                val weightMean = weightSample.average()
                val weightVariance = weightSample.map { (it - weightMean) * (it - weightMean) }.average()
                val weightStdDev = sqrt(weightVariance)

                weightStats = mapOf(
                    "count" to weightSample.size,
                    "mean" to weightMean,
                    "stdDev" to weightStdDev,
                    "min" to (weightSample.minOrNull() ?: 0f),
                    "max" to (weightSample.maxOrNull() ?: 0f)
                )
            }
        }

        ModelStats(
            biasCount = biasCount,
            biasMean = biasMean,
            biasStdDev = biasStdDev,
            biasMin = if (biasCount > 0) biasMin else 0f,
            biasMax = if (biasCount > 0) biasMax else 0f,
            weightCount = weightStats?.get("count") as? Int,
            weightMean = weightStats?.get("mean") as? Double,
            weightStdDev = weightStats?.get("stdDev") as? Double,
            weightMin = weightStats?.get("min") as? Float,
            weightMax = weightStats?.get("max") as? Float
        )
    }

    suspend fun generatePlotScript(): Unit = withContext(Dispatchers.IO) {
        isGeneratingScript = true
        runCatching {
            val success = GnuplotGenerator.generateGnuplotScript(project)
            scriptGenerated = success
            if (!success) {
                error = "Failed to generate gnuplot script"
            }
        }.onFailure { e ->
            error = "Error generating script: ${e.message}"
        }

        isGeneratingScript = false
    }

    suspend fun executePlotScript(): Unit = withContext(Dispatchers.IO) {
        runCatching {
            val gnuplotDir = File(File(project.uri), "gnuplot")
            val scriptFile = File(gnuplotDir, "gnuplot-script")
            if (!scriptFile.exists()) {
                error = "Gnuplot script not found at: ${scriptFile.absolutePath}"
                return@runCatching
            }

            // Make the script executable on Unix-like systems
            if (!System.getProperty("os.name").lowercase().contains("windows")) {
                ProcessBuilder("chmod", "+x", scriptFile.absolutePath)
                    .start()
                    .waitFor()
            }

            // Execute the gnuplot script
            val processBuilder = if (System.getProperty("os.name").lowercase().contains("windows")) {
                ProcessBuilder("cmd", "/c", scriptFile.absolutePath)
            } else {
                ProcessBuilder("bash", "-c", "cd \"${gnuplotDir.absolutePath}\" && ./gnuplot-script")
            }

            processBuilder.directory()
            val process = processBuilder.start()

            // Wait for completion with timeout
            val completed = process.waitFor(1, TimeUnit.MINUTES)

            if (!completed) {
                process.destroyForcibly()
                error = "Gnuplot execution timed out after 1 minute"
            } else if (process.exitValue() != 0) {
                val errorOutput = process.errorStream.bufferedReader().readText()
                error = "Gnuplot execution failed with exit code ${process.exitValue()}: $errorOutput"
            } else {
                // Success - check if output files were generated in the gnuplot directory
                val outputFiles = gnuplotDir.listFiles { file ->
                    file.extension.lowercase() in listOf("png", "jpg", "jpeg", "svg", "pdf", "eps")
                }

                if (outputFiles?.isNotEmpty() == true) {
                    error = null // Clear any previous errors
                    println("Gnuplot execution completed successfully. Generated files: ${outputFiles.map { it.name }}")
                } else {
                    error = "Gnuplot completed but no output files were generated"
                }
            }
        }.onFailure { e ->
            error = "Failed to execute gnuplot script: ${e.message}"
        }
    }

    suspend fun reloadImages() = withContext(Dispatchers.IO) {
        runCatching {
            check(heatmapImageFile.exists() && surfaceImageFile.exists())

            // Load heatmap image if it exists
            val job1 = async {
                while (heatmapImageFile.length() == 0L) {
                    delay(100)
                }
                val heatmapBytes = heatmapImageFile.readBytes()
                val heatmapSkiaImage = Image.makeFromEncoded(heatmapBytes)
                heatmapImage = heatmapSkiaImage.toComposeImageBitmap()
            }

            // Load surface image if it exists
            val job2 = async {
                while (surfaceImageFile.length() == 0L) {
                    delay(100)
                }
                val surfaceBytes = surfaceImageFile.readBytes()
                val surfaceSkiaImage = Image.makeFromEncoded(surfaceBytes)
                surfaceImage = surfaceSkiaImage.toComposeImageBitmap()
            }

            awaitAll(job1, job2)
        }.onFailure { e ->
            error = "Failed to load images: ${e.message}"
        }
    }

    suspend fun reload() = withContext(Dispatchers.IO) {
        // Validate that required files exist
        if (!project.biasFile.exists()) {
            error = "Bias file not found: ${project.biasFile.absolutePath}"
            isLoading = false

            return@withContext
        }

        runCatching {
            // Calculate statistics without loading full data
            modelStats = calculateModelStats()
            dataValidated = true
        }.onFailure { e ->
            error = "Failed to validate model data: ${e.message}"
            isLoading = false
            return@withContext
        }

        runCatching {
            if (!surfaceImageFile.exists() || !heatmapImageFile.exists()) {
                generatePlotScript()
                executePlotScript()
            }
            reloadImages()
        }.onFailure {
            error = "Fail to generate images $it"
            isLoading = false
            return@withContext
        }

        isLoading = false
    }
}

// Data class to hold basic model statistics without storing the full data
data class ModelStats(
    val biasCount: Int,
    val biasMean: Double,
    val biasStdDev: Double,
    val biasMin: Float,
    val biasMax: Float,
    val weightCount: Int?,
    val weightMean: Double?,
    val weightStdDev: Double?,
    val weightMin: Float?,
    val weightMax: Float?
)